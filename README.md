# -# README

## Реализованные алгоритмы

В рамках проекта реализованы следующие алгоритмы, соответствующие интерфейсам библиотеки `heroes_task_lib`:

### 1. GeneratePreset — генерация армии противника

Алгоритм формирует пресет армии компьютера на основе списка типов юнитов и максимального лимита очков. Приоритет выбора юнитов определяется по соотношению **атака / стоимость** (основной критерий) и **здоровье / стоимость** (вторичный критерий). Для каждого типа юнита добавляется не более 11 экземпляров, пока не будет достигнут лимит очков.

### 2. SimulateBattle — пошаговая симуляция боя

Алгоритм моделирует бой между армией игрока и армией компьютера. В каждом раунде все живые юниты сортируются по убыванию значения атаки и выполняют действия по очереди. После каждой атаки погибшие юниты немедленно исключаются из очереди. Симуляция завершается, когда у одной из армий не остаётся живых юнитов.

### 3. SuitableForAttackUnitsFinder — поиск целей, доступных для атаки

Алгоритм формирует список юнитов противника, которые могут быть выбраны в качестве целей. Юниты, закрытые союзниками с фронтальной стороны (слева для левой армии, справа для правой армии), исключаются из списка. Обход выполняется построчно для трёх рядов построения.

### 4. UnitTargetPathFinder — поиск кратчайшего пути между юнитами

Алгоритм находит кратчайший маршрут на игровом поле между атакующим и целевой единицей, используя графовый алгоритм на сетке с возможностью диагонального перемещения. Занятые клетками другими юнитами позиции рассматриваются как препятствия. В случае отсутствия доступного пути возвращается пустой список.

---

## Оценка алгоритмической сложности

### GeneratePreset

Формирование армии выполняется путём последовательного перебора типов юнитов и добавления экземпляров каждого типа до достижения лимитов.

* (n) — количество типов юнитов
* (m) — максимальное число юнитов в армии

Сложность: **O(n · m)** — линейная по числу типов и количеству добавляемых юнитов.

### SimulateBattle

В каждом раунде выполняется сортировка списка юнитов по атаке и итерация по очереди ходов с возможным пересчётом из‑за потерь.

* (n) — общее количество юнитов в бою

Сложность: **O(n² · log n)** или лучше:

* сортировка очереди хода — (O(n · log n))
* серия ходов с перерасчётом очереди в ходе боя — до (O(n²))

### SuitableForAttackUnitsFinder

Обход юнитов выполняется построчно, при этом количество рядов фиксировано и равно трём.

* (k) — количество юнитов в строке

Сложность: **O(k)** (фактически линейная по длине ряда, т.к. число рядов константно).

### UnitTargetPathFinder

Поиск пути выполняется на сетке поля с использованием алгоритма на графе (Дейкстра / A*), где вершины — клетки, рёбра — допустимые перемещения.

* WIDTH = 27
* HEIGHT = 21

Сложность: **O((WIDTH · HEIGHT) · log(WIDTH · HEIGHT))**

Так как размеры поля фиксированы, сложность ограничена сверху и укладывается в требуемые показатели производительности.

---

## Итог

Все реализованные алгоритмы соответствуют функциональным требованиям проекта и удовлетворяют ограничениям по алгоритмической сложности, указанным в спецификации задания.
